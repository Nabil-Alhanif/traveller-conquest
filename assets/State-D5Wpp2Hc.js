import{h as q,u as k,e as X,B as x}from"./index-BCUWOVe7.js";const b=Object.create(null),B=Object.create(null);function $(r,t){let e=B[r];return e===void 0&&(b[t]===void 0&&(b[t]=1),B[r]=e=b[t]++),e}let g;function Y(){if(!g){g="mediump";const r=q();r&&r.getShaderPrecisionFormat&&(g=r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.HIGH_FLOAT).precision?"highp":"mediump")}return g}function Z(r,t,e){return t?r:e?(r=r.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${r}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${r}
        `}function J(r,t,e){const s=e?t.maxSupportedFragmentPrecision:t.maxSupportedVertexPrecision;if(r.substring(0,9)!=="precision"){let i=e?t.requestedFragmentPrecision:t.requestedVertexPrecision;return i==="highp"&&s!=="highp"&&(i="mediump"),`precision ${i} float;
${r}`}else if(s!=="highp"&&r.substring(0,15)==="precision highp")return r.replace("precision highp","precision mediump");return r}function Q(r,t){return t?`#version 300 es
${r}`:r}const tt={},et={};function rt(r,{name:t="pixi-program"},e=!0){t=t.replace(/\s+/g,"-"),t+=e?"-fragment":"-vertex";const s=e?tt:et;return s[t]?(s[t]++,t+=`-${s[t]}`):s[t]=1,r.indexOf("#define SHADER_NAME")!==-1?r:`${`#define SHADER_NAME ${t}`}
${r}`}function st(r,t){return t?r.replace("#version 300 es",""):r}const y={stripVersion:st,ensurePrecision:J,addProgramDefines:Z,setProgramName:rt,insertVersion:Q},P=Object.create(null),L=class O{constructor(t){t={...O.defaultOptions,...t};const e=t.fragment.indexOf("#version 300 es")!==-1,s={stripVersion:e,ensurePrecision:{requestedFragmentPrecision:t.preferredFragmentPrecision,requestedVertexPrecision:t.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:Y()},setProgramName:{name:t.name},addProgramDefines:e,insertVersion:e};let i=t.fragment,n=t.vertex;Object.keys(y).forEach(a=>{const o=s[a];i=y[a](i,o,!0),n=y[a](n,o,!1)}),this.fragment=i,this.vertex=n,this._key=$(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(t){const e=`${t.vertex}:${t.fragment}`;return P[e]||(P[e]=new O(t)),P[e]}};L.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let it=L;const U={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function nt(r){return U[r]??U.float32}const ot={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function at({source:r,entryPoint:t}){const e={},s=r.indexOf(`fn ${t}`);if(s!==-1){const i=r.indexOf("->",s);if(i!==-1){const n=r.substring(s,i),a=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let o;for(;(o=a.exec(n))!==null;){const f=ot[o[3]]??"float32";e[o[2]]={location:parseInt(o[1],10),format:f,stride:nt(f).stride,offset:0,instance:!1,start:0}}}}return e}function v(r){var d,m;const t=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,e=/@group\((\d+)\)/,s=/@binding\((\d+)\)/,i=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,a=/struct\s+(\w+)\s*{([^}]+)}/g,o=/(\w+)\s*:\s*([\w\<\>]+)/g,f=/struct\s+(\w+)/,c=(d=r.match(t))==null?void 0:d.map(l=>({group:parseInt(l.match(e)[1],10),binding:parseInt(l.match(s)[1],10),name:l.match(i)[2],isUniform:l.match(i)[1]==="<uniform>",type:l.match(n)[1]}));if(!c)return{groups:[],structs:[]};const u=((m=r.match(a))==null?void 0:m.map(l=>{const p=l.match(f)[1],D=l.match(o).reduce((N,W)=>{const[I,K]=W.split(":");return N[I.trim()]=K.trim(),N},{});return D?{name:p,members:D}:null}).filter(({name:l})=>c.some(p=>p.type===l)))??[];return{groups:c,structs:u}}var h=(r=>(r[r.VERTEX=1]="VERTEX",r[r.FRAGMENT=2]="FRAGMENT",r[r.COMPUTE=4]="COMPUTE",r))(h||{});function ut({groups:r}){const t=[];for(let e=0;e<r.length;e++){const s=r[e];t[s.group]||(t[s.group]=[]),s.isUniform?t[s.group].push({binding:s.binding,visibility:h.VERTEX|h.FRAGMENT,buffer:{type:"uniform"}}):s.type==="sampler"?t[s.group].push({binding:s.binding,visibility:h.FRAGMENT,sampler:{type:"filtering"}}):s.type==="texture_2d"&&t[s.group].push({binding:s.binding,visibility:h.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return t}function ct({groups:r}){const t=[];for(let e=0;e<r.length;e++){const s=r[e];t[s.group]||(t[s.group]={}),t[s.group][s.name]=s.binding}return t}function lt(r,t){const e=new Set,s=new Set,i=[...r.structs,...t.structs].filter(a=>e.has(a.name)?!1:(e.add(a.name),!0)),n=[...r.groups,...t.groups].filter(a=>{const o=`${a.name}-${a.binding}`;return s.has(o)?!1:(s.add(o),!0)});return{structs:i,groups:n}}const _=Object.create(null);class T{constructor(t){var o,f;this._layoutKey=0;const{fragment:e,vertex:s,layout:i,gpuLayout:n,name:a}=t;if(this.name=a,this.fragment=e,this.vertex=s,e.source===s.source){const c=v(e.source);this.structsAndGroups=c}else{const c=v(s.source),u=v(e.source);this.structsAndGroups=lt(c,u)}this.layout=i??ct(this.structsAndGroups),this.gpuLayout=n??ut(this.structsAndGroups),this.autoAssignGlobalUniforms=((o=this.layout[0])==null?void 0:o.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((f=this.layout[1])==null?void 0:f.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:t,fragment:e}=this,s=t.source+e.source+t.entryPoint+e.entryPoint;this._layoutKey=$(s,"program")}get attributeData(){return this._attributeData??(this._attributeData=at(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(t){const e=`${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;return _[e]||(_[e]=new T(t)),_[e]}}const R=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>"],ft=R.reduce((r,t)=>(r[t]=!0,r),{});function dt(r,t){switch(r){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*t);case"vec3<f32>":return new Float32Array(3*t);case"vec4<f32>":return new Float32Array(4*t);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const V=class C{constructor(t,e){this._touched=0,this.uid=k("uniform"),this._resourceType="uniformGroup",this._resourceId=k("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,e={...C.defaultOptions,...e},this.uniformStructures=t;const s={};for(const i in t){const n=t[i];if(n.name=i,n.size=n.size??1,!ft[n.type])throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${R.join(", ")}`);n.value??(n.value=dt(n.type,n.size)),s[i]=n.value}this.uniforms=s,this._dirtyId=1,this.ubo=e.ubo,this.isStatic=e.isStatic,this._signature=$(Object.keys(s).map(i=>`${i}-${t[i].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};V.defaultOptions={ubo:!1,isStatic:!1};let mt=V;var z=(r=>(r[r.WEBGL=1]="WEBGL",r[r.WEBGPU=2]="WEBGPU",r[r.BOTH=3]="BOTH",r))(z||{});class j extends X{constructor(t){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:e,glProgram:s,groups:i,resources:n,compatibleRenderers:a,groupMap:o}=t;this.gpuProgram=e,this.glProgram=s,a===void 0&&(a=0,e&&(a|=z.WEBGPU),s&&(a|=z.WEBGL)),this.compatibleRenderers=a;const f={};if(!n&&!i&&(n={}),n&&i)throw new Error("[Shader] Cannot have both resources and groups");if(!e&&i&&!o)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!e&&i&&o)for(const c in o)for(const u in o[c]){const d=o[c][u];f[d]={group:c,binding:u,name:d}}else if(e&&i&&!o){const c=e.structsAndGroups.groups;o={},c.forEach(u=>{o[u.group]=o[u.group]||{},o[u.group][u.binding]=u.name,f[u.name]=u})}else if(n){i={},o={},e&&e.structsAndGroups.groups.forEach(d=>{o[d.group]=o[d.group]||{},o[d.group][d.binding]=d.name,f[d.name]=d});let c=0;for(const u in n)f[u]||(i[99]||(i[99]=new x,this._ownedBindGroups.push(i[99])),f[u]={group:99,binding:c,name:u},o[99]=o[99]||{},o[99][c]=u,c++);for(const u in n){const d=u;let m=n[u];!m.source&&!m._resourceType&&(m=new mt(m));const l=f[d];l&&(i[l.group]||(i[l.group]=new x,this._ownedBindGroups.push(i[l.group])),i[l.group].setResource(m,l.binding))}}this.groups=i,this._uniformBindMap=o,this.resources=this._buildResourceAccessor(i,f)}addResource(t,e,s){var i,n;(i=this._uniformBindMap)[e]||(i[e]={}),(n=this._uniformBindMap[e])[s]||(n[s]=t),this.groups[e]||(this.groups[e]=new x,this._ownedBindGroups.push(this.groups[e]))}_buildResourceAccessor(t,e){const s={};for(const i in e){const n=e[i];Object.defineProperty(s,n.name,{get(){return t[n.group].getResource(n.binding)},set(a){t[n.group].setResource(a,n.binding)}})}return s}destroy(t=!1){var e,s;this.emit("destroy",this),t&&((e=this.gpuProgram)==null||e.destroy(),(s=this.glProgram)==null||s.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(i=>{i.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(t){const{gpu:e,gl:s,...i}=t;let n,a;return e&&(n=T.from(e)),s&&(a=it.from(s)),new j({gpuProgram:n,glProgram:a,...i})}}const ht={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},G=0,E=1,F=2,w=3,A=4,M=5,S=class H{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<G)}set blend(t){!!(this.data&1<<G)!==t&&(this.data^=1<<G)}get offsets(){return!!(this.data&1<<E)}set offsets(t){!!(this.data&1<<E)!==t&&(this.data^=1<<E)}set cullMode(t){if(t==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=t==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<F)}set culling(t){!!(this.data&1<<F)!==t&&(this.data^=1<<F)}get depthTest(){return!!(this.data&1<<w)}set depthTest(t){!!(this.data&1<<w)!==t&&(this.data^=1<<w)}get depthMask(){return!!(this.data&1<<M)}set depthMask(t){!!(this.data&1<<M)!==t&&(this.data^=1<<M)}get clockwiseFrontFace(){return!!(this.data&1<<A)}set clockwiseFrontFace(t){!!(this.data&1<<A)!==t&&(this.data^=1<<A)}get blendMode(){return this._blendMode}set blendMode(t){this.blend=t!=="none",this._blendMode=t,this._blendModeId=ht[t]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(t){this.offsets=!!t,this._polygonOffset=t}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const t=new H;return t.depthTest=!1,t.blend=!0,t}};S.default2d=S.for2d();let pt=S;export{T as G,z as R,j as S,mt as U,pt as a,it as b,$ as c,nt as g};
